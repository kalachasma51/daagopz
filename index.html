<!DOCTYPE html>
<html>
<head>
    <title>yeeee P K</title>
</head>
     <style>
          body {
            background-color: black;
        }
        pre {
            color: white;
        }
    </style>
<body>
    <pre>


PART-A
1) Write a C program to search for a key element in the list of n element in non-decreasing order
using linear search technique.
Algorithm:
ALGORITHM : Linear_Search(A[0..n − 1], K)
//Searches for a given value in a given array by sequential search
//Input: An array A[0..n − 1] and a search key K
//Output: The index of the first element in A that matches K or −1 if there are no matching elements
i ←0
while i < n and A[i] ≠ K do
i ←i + 1
if i < n return i
else return −1


Code:










#include <stdio.h>
int linearsearch(int a[], int n, int key);
int main() {
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
printf("Enter the elements of the array: ");
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
int key;
printf("Enter the key to search: ");
scanf("%d", &key);
int result = linearsearch(a, n, key);
if (result != -1)
printf("Key %d found at index %d\n", key, result);
else
printf("Key %d not found in the array\n", key);
return 0;
}
int linearsearch(int a[], int n, int key) {
Efficiency: O(n)
3 |
int i = 0;
while (i < n && a[i] != key)
i = i + 1;
if (i < n)
return i; // Key found at index i
else
return -1; // Key not found in the array
}
Output:
i)
Enter the number of elements: 5
Enter the elements of the array: 56 -98 67 44 67
Enter the key to search: 67
Key 67 found at index 2
ii)
Enter the number of elements: 5
Enter the elements of the array: 87 43 54 99 78
Enter the key to search: 8
Key 8 not found in the array




2)Write a C program to sort array of n elements in non-decreasing order using bubble sort
technique.
Algorithm:
BubbleSort(A[0..n − 1])
//Sorts a given array by bubble sort
//Input: An array A[0..n − 1] of orderable elements
//Output: Array A[0..n − 1] sorted in nondecreasing order
for i ←0 to n − 2 do
for j ←0 to n − 2 − i do
if A[j ]>A[j+1]
swap A[j ] , A[j + 1]



Code:
#include <stdio.h>
#include <stdlib.h>
void getdata(int[],int);
void display(int[],int);
void bubblesort(int[],int);
int main()
4 |
{
int n;
printf("Enter the number of elements :");
scanf("%d",&n);
int a[n];
getdata(a,n);
printf("Elements before sorting :");
display(a,n);
bubblesort(a,n);
printf("Elements after sorting :");
display(a,n);
return 0;
}
void getdata(int a[], int n)
{
for(int i=0;i<n;i++)
scanf("%d",&a[i]);
}
void display(int a[ ], int n)
{
for(int i=0;i<n;i++)
{
printf("%d \t",a[i]);
}
printf("\n");
}
void bubblesort(int a[],int n)
{
for(int i=0;i<=n-2;i++)
{
for(int j=0;j<=n-2 -i;j++)
{
if(a[j]>a[j+1])
{
int temp=a[j];
a[j]=a[j+1];
a[j+1]=temp;
}
}
}
}


Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98
5 |
------------------------------------------------------------------------------------------------------------------------------------------------------------------


3)Write a C program to sort array of n elements in non-decreasing order using selection sort
technique.
Algorithm:
SelectionSort(A[0..n − 1])
//Sorts a given array by selection sort
//Input: An array A[0..n − 1] of orderable elements
//Output: Array A[0..n − 1] sorted in nondecreasing order
for i ←0 to n − 2 do
min←i
for j ←i + 1 to n − 1 do
if A[j ]<A[min]
min←j
swap A[i] and A[min]
/*
extra:-
swap A[i] and A[min]
temp<-A[min]
A[min]<-A[i]
A[i]<-temp
*/
Code:


#include <stdio.h>
#include <stdlib.h>
void getdata(int[],int);
void display(int[],int);
void selectionsort(int[],int);
int main()
{
int n;
printf("Enter the number of elements :");
scanf("%d",&n);
int a[n];
getdata(a,n);
printf("Elements before sorting :");
6 |
display(a,n);
selectionsort(a,n);
printf("Elements after sorting :");
display(a,n);
return 0;
}
void getdata(int a[], int n)
{
for(int i=0;i<n;i++)
scanf("%d",&a[i]);
}
void display(int a[ ], int n)
{
for(int i=0;i<n;i++)
{
printf("%d \t",a[i]);
}
printf("\n");
}
void selectionsort(int a[],int n)
{
int t;
for(int i=0;i<=n-2;i++)
{
int min=i;
for(int j=i+1;j<=n-1;j++)
if(a[j]<a[min])
min=j;
t=a[min];
a[min]=a[i];
a[i]=t;
7 |
}
}

Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98

------------------------------------------------------------------------------------------------------------------------------------------------------------------
4) Write a C program to search the pattern in the given text using brute force string matching
algorithm. Assume matching done by ignoring case-sensitivity of alphabets.
Algorithm:
BruteForceStringMatch(T [0..n − 1], P[0..m − 1])
//Implements brute-force string matching
//Input: An array T [0..n − 1] of n characters representing a text and
// an array P[0..m − 1] of m characters representing a pattern
//Output: The index of the first character in the text that starts a matching substring or −1 if the
search is unsuccessful
for i ←0 to n − m do
j ←0
while j <mand P[j ]= T [i + j ] do
j ←j + 1
if j = m
return i
return −1
Code:


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h> // Include ctype.h for case-insensitive comparisons
int strmatch(char s1[100], char s2[100]);
int main() {
char text[100], pattern[100];
printf("Enter the text: ");
8 |
scanf("%s", text);
printf("Enter the pattern to find: ");
scanf("%s", pattern);
int result = strmatch(text, pattern);
if (result == -1)
printf("Pattern not found\n");
else
printf("Pattern found at index %d\n", result);
return 0;
}
int strmatch(char text[100], char pattern[100]) {
int i, j, n, m;
n = strlen(text);
m = strlen(pattern);
// Convert text and pattern to lowercase for case-insensitive comparison
strlwr(text);
strlwr(pattern);
for (i = 0; i <= n - m; i++) {
j = 0;
while (j < m && text[i + j] == pattern[j])
j++;
if (j == m)
return i;
}
return -1;
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
i)
Enter the text: deepit_nayak
Enter the pattern to find: Yak
Pattern found at index 9
ii)
Enter the text: deepit_nayak
Enter the pattern to find: yek
Pattern not found

------------------------------------------------------------------------------------------------------------------------------------------------------------------
5) Write a C program to sort array of n elements in non-decreasing order using insertion sort
technique.
Algorithm:
InsertionSort(A[0..n − 1])
9 |
//Sorts a given array by insertion sort
//Input: An array A[0..n − 1] of n orderable elements
//Output: Array A[0..n − 1] sorted in nondecreasing order
for i ←1 to n − 1 do
v ←A[i]
j ←i − 1
while j ≥ 0 and A[j ]> v do
A[j + 1]←A[j ]
j ←j − 1
A[j + 1]←v
Code:
i) non recursive method




#include <stdio.h>
#include <stdlib.h>
void getdata(int[], int);
void display(int[], int);
void insertionSort(int[], int);
int main() {
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
printf("Elements before sorting:\n");
display(a, n);
insertionSort(a, n);
10 |
printf("Elements after sorting:\n");
display(a, n);
return 0;
}
void getdata(int a[], int n) {
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
void display(int a[], int n) {
for (int i = 0; i < n; i++) {
printf("%d\t", a[i]);
}
printf("\n");
}
void insertionSort(int a[], int n) {
int i, v, j;
for (i = 1; i < n; i++) {
v = a[i];
j = i - 1;
while (j >= 0 && a[j] > v) {
a[j + 1] = a[j];
j = j - 1;
}
a[j + 1] = v;
}
}
ii) recursive method
Algorithm:
11 |
R_InsertionSort(A[0..n − 1])
//Sorts a given array by recursive insertion sort
//Input: An array A[0..n − 1] of n orderable elements
//Output: Array A[0..n − 1] sorted in nondecreasing order
if n<=1 then
return
R_InsertionSort(A[0..n − 2])
v ←A[n-1]
j ←n-2
while j ≥ 0 and A[j ]> v do
A[j + 1]←A[j ]
j ←j − 1
A[j + 1]←v
Code:
#include <stdio.h>
#include <stdlib.h>
void getdata(int[], int);
void display(int[], int);
void insertionSortRecursive(int[], int);
int main() {
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
printf("Elements before sorting:\n");
display(a, n);
insertionSortRecursive(a, n);
printf("Elements after sorting:\n");
display(a, n);
return 0;
}
void getdata(int a[], int n) {
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
void display(int a[], int n) {

for (int i = 0; i < n; i++) {
printf("%d\t", a[i]);
}
printf("\n");
}
void insertionSortRecursive(int a[], int n) {
if (n <= 1)
return;
insertionSortRecursive(a, n - 1);
int l = a[n - 1];
int j = n - 2;
while (j >= 0 && a[j] > l) {
a[j + 1] = a[j];
j--;
}
a[j + 1] = l;
}

Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting : -41 -14 -4 14 41 87 87 90 98 98

------------------------------------------------------------------------------------------------------------------------------------------------------------------
6) Write a C program to compute all pair shortest path of a positive weighted graph using Floyd’s
algorithm.
Algorithm:
Floyd(W[1..n, 1..n])
//Implements Floyd’s algorithm for the all-pairs shortest-paths problem
//Input: The weight matrix W of a graph with no negative-length cycle
//Output: The distance matrix of the shortest paths’ lengths
D ←W //is not necessary if W can be overwritten
for k←1 to n do
for i ←1 to n do
for j ←1 to n do
13 |
D[i, j ]←min{D[i, j ], D[i, k]+ D[k, j]}
return D
Code:









#include <stdio.h>
#include <stdlib.h>
#define max 10
void floyds(int[max][max], int);
int min(int, int);
int main() {
int weight[max][max], n, i, j;
printf("Enter number of vertices: ");
scanf("%d", &n);
printf("Enter the weight matrix:\n");
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
scanf("%d", &weight[i][j]);
floyds(weight, n);
printf("All pair shortest path matrix:\n");
for (i = 1; i <= n; i++) {
for (j = 1; j <= n; j++)
printf("%d\t", weight[i][j]);
printf("\n");
}
return 0;
}
void floyds(int weight[max][max], int n) {
int i, j, k;
for (k = 1; k <= n; k++)
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j]);
}
int min(int a, int b) {
if (a < b)
return a;
else
return b;
14 |
}



------------------------------------------------------------------------------------------------------------------------------------------------------------------
7) Write a C program to compute transitive closure of a graph using Warshall’s algorithm.
Algorithm:
Warshall(A[1..n, 1..n])
//ImplementsWarshall’s algorithm for computing the transitive closure
//Input: The adjacency matrix A of a digraph with n vertices
//Output: The transitive closure of the digraph
R(0) ←A
for k←1 to n do
for i ←1 to n do
for j ←1 to n do
R(k)[i, j ]←R(k−1)[i, j ] or (R(k−1)[i, k] and R(k−1)[k, j])
return R(n)
code:



#include <stdio.h>
#include <stdlib.h>
#define max 10
void warshall(int[max][max], int);
int max_(int, int);
int main() {
int adj_mat[max][max], n, i, j;
15 |
printf("Enter number of vertices: ");
scanf("%d", &n);
printf("\nEnter Adjacency matrix:\n");
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
scanf("%d", &adj_mat[i][j]);
warshall(adj_mat, n);
printf("\nTransitive closure:\n");
for (i = 1; i <= n; i++) {
printf("\n");
for (j = 1; j <= n; j++)
printf("%d\t", adj_mat[i][j]);
}
return 0;
}
void warshall(int adj_mat[max][max], int n) {
int i, j, k;
for (k = 1; k <= n; k++)
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
adj_mat[i][j] = max_(adj_mat[i][j], adj_mat[i][k] && adj_mat[k][j]);
}
int max_(int a, int b) {
if (a > b)
return a;
else
return b;
}





------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
PART-B
1)Write a C program to sort array of n elements in non-decreasing order using quick sort
technique.
Algorithm:
Quicksort(A[l..r])
//Sorts a subarray by quicksort
//Input: Subarray of array A[0..n − 1], defined by its left and right indices l and r
//Output: Subarray A[l..r] sorted in nondecreasing order
if l < r
s ←Partition(A[l..r]) //s is a split position
Quicksort(A[l..s − 1])
Quicksort(A[s + 1..r])
HoarePartition(A[l..r])
//Partitions a subarray by Hoare’s algorithm, using the first element as a pivot
//Input: Subarray of array A[0..n − 1], defined by its left and right indices l and r (l<r)
//Output: Partition of A[l..r], with the split position returned as this function’s value
p←A[l]
i ←l;
j ←r + 1
repeat
repeat i ←i + 1 until A[i]≥ p
repeat j ←j − 1 until A[j ]≤ p
swap(A[i], A[j ])
until i ≥ j
swap(A[i], A[j ]) //undo last swap when i ≥ j
swap(A[l], A[j ])
return j
Code:

------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
void getdata(int[], int);
void display(int[], int);
void swap(int[],int,int);
void quicksort(int[],int,int);
int Partition(int [], int , int ) ;
int main()
{
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
printf("Elements before sorting: ");
display(a, n);
int l = 0;
int r = n - 1;
quicksort(a,l,r);
printf("Elements after sorting: ");
display(a, n);
return 0;
}
void getdata(int a[], int n)
{
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
void display(int a[], int n)
{
for (int i = 0; i < n; i++)
{
18 |
printf("%d \t", a[i]);
}
printf("\n");
}
void quicksort(int a[],int l,int r)
{
if(l<r)
{
int s=Partition(a,l,r); //Partition the array into sub-array based on pivot element
quicksort(a,l,s-1); //Sort first sub-array
quicksort(a,s+1,r); //Sort second sub-array
}
}
int Partition(int a[], int l, int r) {
int p, i, j;
p = a[l];
i = l;
j = r + 1;
do {
do {
i++;
} while (a[i] < p);
do {
j--;
} while (a[j] > p);
swap(a, i, j);
} while (i < j);
swap(a,i,j);
swap(a, l, j);
return j;
}
void swap(int a[],int i,int j){
int temp;
temp=a[i];
a[i]=a[j];
a[j]=temp;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
19 |
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
2)Write a C program to sort array of n elements in non-decreasing order using merge sort
technique.
Algorithm:
mergesort(a[0…n-1], low, high)
//Sorts array a[0..n − 1] by recursive mergesort
//Input: An array a[0..n − 1] of orderable elements
//Output: Array a[0..n − 1] sorted in nondecreasing order
mergesort(a[0…n-1], low, high)
if low < high
mid <- (low + high) / 2
mergesort(a, low, mid)
mergesort(a, mid + 1, high)
merge(a, low, mid, high)
Merge(a[0…n-1],low, mid, high)
i ←low
j ←mid+1
k←low
while i <=mid and j <=high do
if a[i]≤ a[j ]
b[k]←a[i++]
else
b[k] ←a[j++]
k←k+1
while i<=mid do
b[k] ←a[i++]
k←k+1
while j<=high do
b[k] ←a[j++]
20 |
k←k+1
//copy array b into array a
for i ← low to high do
a[i]=b[i]
Code:

------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
void getdata(int[], int);
void display(int[], int);
void mergesort(int[], int, int);
void merge(int[], int, int, int);
int main()
{
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
printf("Elements before sorting: ");
display(a, n);
int low = 0;
int high = n - 1;
printf("Low: %d\nHigh: %d\n", low, high);
mergesort(a, low, high);
printf("Elements after sorting: ");
display(a, n);
return 0;
}
void getdata(int a[], int n)
{
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
21 |
void display(int a[], int n)
{
for (int i = 0; i < n; i++)
{
printf("%d \t", a[i]);
}
printf("\n");
}
void mergesort(int a[], int low, int high)
{
int mid;
if (low < high)
{
mid = (low + high) / 2;
mergesort(a, low, mid);
mergesort(a, mid + 1, high);
merge(a, low, mid, high);
}
}
void merge(int a[], int low, int mid, int high)
{
int i = low;
int j = mid + 1;
int k = low;
int b[high + 1];
while (i <= mid && j <= high)
{
if (a[i] <= a[j])
{
b[k] = a[i];
i = i + 1;
}
else
{
b[k] = a[j];
j = j + 1;
}
k = k + 1;
}
while (i <= mid)
{
b[k] = a[i];
i = i + 1;
22 |
k = k + 1;
}
while (j <= high)
{
b[k] = a[j];
j = j + 1;
k = k + 1;
}
for (int i = low; i <= high; i++)
{
a[i] = b[i];
}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
3)Write a C program to traverse all vertices of graph (directed or undirected) using DFS graph
traversal technique.
23 |

------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#define MAX 10
void dfs(int, int[MAX][MAX], int[MAX]);
int main() {
int adj[MAX][MAX], n, source, v[MAX], flag = 1;
printf("Enter the number of vertices: ");
scanf("%d", &n);
printf("Enter the adjacency matrix:\n");
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
scanf("%d", &adj[i][j]);
}
}
printf("Enter source vertex: ");
scanf("%d", &source);
for (int i = 0; i < n; i++) {
v[i] = 0;
}
printf("DFS Traversal:\n");
dfs(source, adj, v);
for (int i = 0; i < n; i++) {
if (v[i] == 0) {
flag = 0;
break;
}
}
if (flag == 1)
printf("Graph connected\n");
else
printf("Graph not connected\n");
return 0;
}
void dfs(int source, int adj[MAX][MAX], int v[MAX]) {
v[source] = 1;
printf("Visited node %d\n", source);
24 |
for (int i = 0; i < MAX; i++) {
if (adj[source][i] == 1 && v[i] == 0) {
dfs(i, adj, v);
}
}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Output:
i)
Enter the number of vertices: 4
Enter the adjacency matrix:
0 1 1 0
1 0 0 1
1 0 0 0
0 1 0 0
Enter source vertex: 0
DFS Traversal:
Visited node 0
Visited node 1
Visited node 3
Visited node 2
Graph connected
ii)
Enter the number of vertices: 4
Enter the adjacency matrix:
0 1 0 0
0 1 0 0
0 0 1 0
1 0 0 0
Enter source vertex: 0
DFS Traversal:
25 |
Visited node 0
Visited node 1
Graph not connected

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
4)Write a C program to traverse all vertices of graph (directed or undirected) using BFS graph
traversal technique.
Code:


#include <stdio.h>
#include <stdlib.h>
#define MAX 10
void bfs(int, int[MAX][MAX], int[MAX]);
int main() {
int adj[MAX][MAX], n, source, v[MAX], flag = 1;
printf("Enter the number of vertices: ");
scanf("%d", &n);
printf("Enter the adjacency matrix:\n");
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
scanf("%d", &adj[i][j]);
}
}
printf("Enter source vertex: ");
26 |
scanf("%d", &source);
for (int i = 0; i < n; i++) {
v[i] = 0;
}
printf("BFS Traversal:\n");
bfs(source, adj, v);
for (int i = 0; i < n; i++) {
if (v[i] == 0) {
flag = 0;
break;
}
}
if (flag == 1)
printf("Graph connected\n");
else
printf("Graph not connected\n");
return 0;
}
void bfs(int source, int adj[MAX][MAX], int v[MAX]) {
int q[MAX], rear = -1, u, front = 0;
v[source] = 1;
printf("Visited node %d\n", source);
q[++rear] = source;
while (front <= rear) {
u = q[front++];
for (int i = 0; i < MAX; i++) {
if (adj[u][i] == 1 && v[i] == 0) {
v[i] = 1;
printf("Visited node %d\n", i);
q[++rear] = i;
}
}
}
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
i)Enter the number of vertices: 4
Enter the adjacency matrix:
0 1 1 0
1 0 0 1
1 0 0 0
0 1 0 0
Enter source vertex: 0
BFS Traversal:
27 |
Visited node 0
Visited node 1
Visited node 2
Visited node 3
Graph connected
ii)
Enter the number of vertices: 4
Enter the adjacency matrix:
0 0 0 0
1 0 0 0
0 0 1 0
0 0 1 0
Enter source vertex: 1
BFS Traversal:
Visited node 1
Visited node 0
Graph not connected

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
5)Write a C program to perform topological sorting on a directed graph.
Algorithm:
TopologicalSort(G(V,E),n)
//Perform topological sort on a directed graph
//Input: Directed Graph G = (V, E)
//Output: Graph G whose vertices are display in topological sorted order
//Initialize an empty queue
for i←0 to n-1
indegree[i]←0
for i←0 to n-1
for j←0 to n-1
if adj[i][j]=1
indegree[j]←indegree[j]+1
for i←0 to n-1

if indegree[i]=0
enqueue(queue,i)
while queue is not empty
v←deque(queue)
append T with v
for j←0 to n-1
if adj[v][i]==1 && visited[j]=0
indegree[j]←indegree[j]-1
if indegree[j]=0
enqueue(queue,j)
visited[j]←1
return T









#include <stdio.h>
#include <stdlib.h>
#define max 10
int adj[max][max], visited[max], T[max], indegree[max];
void topological_sorting(int[][max], int);
int main() {
int i, j, n;
printf("\nEnter number of vertices: \n");
scanf("%d", &n);
printf("\nEnter adjacency matrix for the graph\n");
for (i = 0; i < n; i++) {
printf("\nEnter row %d\n", (i + 1));
for (j = 0; j < n; j++)
scanf("%d", &adj[i][j]);
}
29 |
topological_sorting(adj, n);
printf("\nTopological Order: ");
for (i = 0; i < n; i++)
printf("%d ", T[i]);
printf("\n");
return 0;
}
void topological_sorting(int adj[][max], int n) {
int i, j, q[max], front = 0, rear = -1, v, idx = 0;
// Initialize visited array
for (i = 0; i < n; i++)
visited[i] = 0;
// Calculate indegree
for (i = 0; i < n; i++)
for (j = 0; j < n; j++)
if (adj[i][j] == 1)
indegree[j]++;
// Initialize queue
for (i = 0; i < n; i++)
if (indegree[i] == 0)
q[++rear] = i;
while (front <= rear) {
v = q[front++];
T[idx++] = v;
visited[v] = 1; // Mark vertex as visited
for (j = 0; j < n; j++) {
if (adj[v][j] == 1 && visited[j] == 0) {
indegree[j]--;
if (indegree[j] == 0)
q[++rear] = j;
}
}

}
}


Output:
Enter number of vertices:
5
Enter adjacency matrix for the graph
Enter row 1
0 0 1 0 0
Enter row 2
1 0 1 0 0
Enter row 3
0 0 0 1 1
Enter row 4
0 0 0 0 1
Enter row 5
0 0 0 0 0
Topological Order: 1 0 2 3 4


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
6) Write a C program to search the pattern in the given text using Horspool’s string matching
algorithm.Assume matching done by ignoring case-sensitivity of alphabets.
Algorithm:
HorspoolMatching (P [0..m − 1], T [0..n − 1])
//Implements Horspool’s algorithm for string matching
//Input: Pattern P[0..m − 1] and text T [0..n − 1]
//Output: The index of the left end of the first matching substring or −1 if there are no matches
ShiftTable(P [0..m − 1]) //generate Table of shifts
i ←m – 1 //position of the pattern’s right end
while i ≤ n − 1 do
k←0 //number of matched characters
while k ≤ m − 1 and P[m − 1− k]= T [i − k] do
k←k + 1
31 |
if k = m
return i − m + 1
else
i ←i + Table[T [i]]
return −1
Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
int table[128];
int m, n;
void ShiftTable(char P[], int m) {
int i, j;
for (i = 0; i < 128; i++)
table[i] = m;
for (j = 0; j <= m - 2; j++)
table[(int)tolower(P[j])] = table[(int)toupper(P[j])] = m - 1 - j;
}
int Horspool(char T[], char P[]) {
int i, k;
ShiftTable(P, m);
i = m - 1;
while (i <= n - 1) {
k = 0;
while (k <= m - 1 && (tolower(P[m - 1 - k]) == tolower(T[i - k])))
k++;
32 |
if (k == m)
return i - m + 1;
else
i += table[(int)T[i]];
}
return -1;
}
int main() {
int pos;
char text[100], pattern[25];
printf("Enter the text:\n");
fgets(text, sizeof(text), stdin);
printf("Enter the pattern:\n");
fgets(pattern, sizeof(pattern), stdin);
n = strlen(text);
m = strlen(pattern) - 1; // Excluding the newline character from fgets
// Convert text and pattern to lowercase for case-insensitive comparison
strlwr(text);
strlwr(pattern);
pos = Horspool(text, pattern);
if (pos == -1)
printf("Pattern not found!!");
else
printf("Pattern %s found at position %d.", pattern, pos + 1);
return 0;
}
Output:
i)
Enter the text:
deepit_nayak
Enter the pattern:
33 |
nayak
Pattern nayak found at position 8.
ii)
Enter the text:
motorola_edge_series
Enter the pattern:
age
Pattern not found!!


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
7)Write a C program to sort array of n elements in non-decreasing order using heap sort technique.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
void swap(int *a, int *b) {
int tempvar = *a;
*a = *b;
*b = tempvar;
}
void heapify(int arr[], int n, int i) {
int greatest = i;

int leftSide = 2 * i + 1;
int rightSide = 2 * i + 2;
if (leftSide < n && arr[leftSide] > arr[greatest])
greatest = leftSide;
if (rightSide < n && arr[rightSide] > arr[greatest])
greatest = rightSide;
if (greatest != i) {
swap(&arr[i], &arr[greatest]);
heapify(arr, n, greatest);
}
}
void heapSort(int arr[], int n) {
for (int i = n / 2 - 1; i >= 0; i--)
heapify(arr, n, i);
for (int i = n - 1; i >= 0; i--) {
swap(&arr[0], &arr[i]);
heapify(arr, i, 0);
}
}
void printArray(int arr[], int n) {
for (int i = 0; i < n; ++i)
printf("%d ", arr[i]);
printf("\n");
}
void getdata(int a[], int n)
{
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
void display(int a[], int n)
{
for (int i = 0; i < n; i++)
{
printf("%d \t", a[i]);
}
printf("\n");
}
int main() {
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
35 |
printf("Elements before sorting: ");
display(a, n);
heapSort(a, n);
printf("Elements after sorting: ");
display(a, n);
return 0;
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98











</pre>
</body>
</html>
