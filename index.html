<!DOCTYPE html>
<html>
<head>
    <title>yeeee P K</title>
</head>
     <style>
          body {
            background-color: black;
        }
        pre {
            color: white;
        }
    </style>
<body>
    <pre>


----------------------------------------------
  1.BINARY SEARCH
==============================================

#include <stdio.h>
#include <stdlib.h>
int main( )
{
int n,mid,key,i,low,high;
printf("Enter the number of elements : ");
scanf("%d",&n);
int a[n];
printf("Enter %d elements in ascending
order : \n",n);
for(i=0; i<n; i++)
scanf("%d",&a[i]);
printf("Enter the key element \n");
scanf("%d",&key);
low=0,high=n-1;
while(low<=high)
{
mid=(low+high)/2;
if(a[mid]==key)
break;
if(key<a[mid])
high=mid-1;
else
low=mid+1;
}
if(low>high)
printf("Key element is not found!");
else
printf("%d is present at position %d
",key,mid+1);
return 0;
}
----------------------------------------------
   2. Linear Search
==============================================
#include <stdio.h>
int main()
{
int n,key,i,arr[100];
printf("Enter the size\n");
scanf("%d",&n);
printf("Enter the elements\n");
for(i=0;i<n;i++)
scanf("%d",&arr[i]);
printf("Enter the key element\n");
scanf("%d",&key);
for(i=0;i<n;i++)
{
if(arr[i]==key)
break;
}
if(i<n)
printf("Element found at position %d",i+1);
else
printf("Element is absent");
}

----------------------------------------------
    3.QUICK SORT
==============================================

#include <stdio.h> 
#include <stdlib.h> 
int main( )
{
int n,i;
printf("Enter the number of elements : "); 
scanf("%d",&n);
int a[n];
printf("Enter %d elements:\n",n); 
for(i=0;i<n;i++)
scanf("%d",&a[i]); 
printf("\nArray before sorting:\n");
for(i=0; i<n;i++) 
printf("%d\t",a[i]); 
QuickSort(a,0,n-1); 
printf("\nArray after sorting:\n"); 
for(i=0;i<n;i++)
printf("%d\t",a[i]); 
return 0;
}
int Partition(int a[],int l,int r)
{
int p,i,j,temp;
p=a[l]; 
i=l; 
j=r+1; 
do
{
do
{
i++;
}while(a[i]<p && i<=r); 
do
{
j--;
}while(a[j]>p);
if(i<=r)
{
temp=a[i]; 
a[i]=a[j]; 
a[j]=temp; 
}
}while(i<j);
if(i<=r)
{
temp=a[i]; 
a[i]=a[j]; 
a[j]=temp; 
}
temp=a[l]; 
a[l]=a[j]; 
a[j]=temp; 
return j;
}
void QuickSort(int a[],int l,int r)
{
if(l<r)
{
int s=Partition(a,l,r); 
QuickSort(a,l,s-1); 
QuickSort(a,s+1,r);
}
}
----------------------------------------------
    4.BUBBLE SORT
==============================================

  #include <stdio.h>
#include <stdlib.h>
int main( )
{
int n,i,j,temp;
printf("Enter the size : ");
scanf("%d",&n);
int a[n];
printf("Enter %d elements : \n",n);
for(i=0;i<n;i++)
scanf("%d",&a[i]);
for(i=0;i<n-1;i++)
{
for(j=0; j<n-1-i; j++)
if(a[j]>a[j+1])
{
temp=a[j];
a[j]=a[j+1];
a[j+1]=temp;
}
}
printf("Elements after sorting :\n");
for(i=0;i<n;i++)
printf("%d\t",a[i]);
return 0;
}


----------------------------------------------------
    5.SELECTION SORT

----------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
int main( )
{
int i,j,min,temp,n;
printf("Enter the size:");
scanf("%d",&n);
int a[n];
printf("Enter %d elements : \n",n);
for(i=0; i<n; i++)
scanf("%d",&a[i]);
for(i=0; i<n-1; i++)
{
min=i;
for(j=i+1; j<n; j++)
{
if(a[j]<a[min])
min=j;
}
temp=a[min];
a[min]=a[i];
a[i]=temp;
}
printf("After Sorting:\n");
for(i=0;i<n;i++)
printf("%d\t",a[i]);
return 0;
}
----------------------------------------------------
    6.Insertion sort
----------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
int main( )
{
int i,n,j,v;
printf("Enter the value of n :");
scanf("%d",&n);
int a[n];
printf("Enter %d element:\n",n);
for(i=0; i<n; i++)
scanf("%d",&a[i]);
printf("Array before sorting:\n");
for(i=0; i<n; i++)
printf("%d\t",a[i]);
for(i=1; i<n; i++)
{
v=a[i];
j=i-1;
while(j>=0 && a[j]>v)
{
a[j+1]=a[j];
j--;
}
a[j+1]=v;
}
printf("\nArray after sorting:\n");
for(i=0; i<n; i++)
printf("%d\t",a[i]);
return 0;
}



----------------------------------------------------
   7.String Matching
----------------------------------------------------


#include <stdio.h>
#include <stdlib.h>
#include<string.h>
int main( )
{
char text[100],pattern[25];
int i,j;
printf("Enter the text : \n");
gets(text);
printf("Enter the pattern :\n");
gets(pattern);
int n=strlen(text);
int m=strlen(pattern);
for(i=0;i<=n-m;i++)
{
j=0;
while(j<m && pattern[j]==text[i+j])
j++;
if(j==m)
{
printf("The pattern is found at position
%d",i+1);
exit(0);
}
}
printf("Pattern Not Found!!");c
return 0;
}

    


    
----------------------------------------------------
        8.MERGE SORT
----------------------------------------------------
    
#include <stdio.h>
#include <stdlib.h>
int main( )
{
int i,n;
printf("Enter the number of elements : ");
scanf("%d",&n);
int a[n];
printf("Enter %d elements :\n",n);
for(i=0; i<n; i++)
scanf("%d",&a[i]);
printf("Array before sorting:\n");
for(i=0; i<n; i++)
printf("%d\t",a[i]);
mergeSort(n,a);
printf("\nArray after sorting:\n");
for(i=0; i<n; i++)
printf("%d\t",a[i]);
return 0;
}
void Merge(int b[],int c[],int a[],int p,int q)
{
int i=0,j=0,k=0;
while(i<p&&j<q)
{
if(b[i]<=c[j])
{
a[k]=b[i];
i++;
}
else
{
a[k]=c[j];
j++;
}
k++;
}
if(i==p)
{
while(j<q && k<(p+q))
{
a[k]=c[j];
j++;
k++;
}
}
else
{
while(i<p && k<(p+q))
{
a[k]=b[i];
k++;
i++;
}
}
}
void mergeSort(int n,int a[])
{
if(n>1)
{
int i,j,len;
len=n/2;
int b[len],c[n-len];
for(i=0,j=0; i<len && j<len; i++,j++)
{
b[j]=a[i];
}
for(i=len,j=0; i<n && j<n-len; i++,j++)
{
c[j]=a[i];
}
mergeSort(len, b);
mergeSort(n-len, c);
Merge(b,c,a,len,n-len);
}
}

____________________________________________________________________



#include <stdio.h>
#include <stdlib.h>
#define max 10
void warshall(int[max][max], int);
int max_(int, int);
int main() {
int adj_mat[max][max], n, i, j;
15 |
printf("Enter number of vertices: ");
scanf("%d", &n);
printf("\nEnter Adjacency matrix:\n");
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
scanf("%d", &adj_mat[i][j]);
warshall(adj_mat, n);
printf("\nTransitive closure:\n");
for (i = 1; i <= n; i++) {
printf("\n");
for (j = 1; j <= n; j++)
printf("%d\t", adj_mat[i][j]);
}
return 0;
}
void warshall(int adj_mat[max][max], int n) {
int i, j, k;
for (k = 1; k <= n; k++)
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
adj_mat[i][j] = max_(adj_mat[i][j], adj_mat[i][k] && adj_mat[k][j]);
}
int max_(int a, int b) {
if (a > b)
return a;
else
return b;
}


_________________________________________________________


#include <stdio.h>
#include <stdlib.h>
#define max 10
void floyds(int[max][max], int);
int min(int, int);
int main() {
int weight[max][max], n, i, j;
printf("Enter number of vertices: ");
scanf("%d", &n);
printf("Enter the weight matrix:\n");
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
scanf("%d", &weight[i][j]);
floyds(weight, n);
printf("All pair shortest path matrix:\n");
for (i = 1; i <= n; i++) {
for (j = 1; j <= n; j++)
printf("%d\t", weight[i][j]);
printf("\n");
}
return 0;
}
void floyds(int weight[max][max], int n) {
int i, j, k;
for (k = 1; k <= n; k++)
for (i = 1; i <= n; i++)
for (j = 1; j <= n; j++)
weight[i][j] = min(weight[i][j], weight[i][k] + weight[k][j]);
}
int min(int a, int b) {
if (a < b)
return a;
else
return b;
}




------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
PART-B
1)Write a C program to sort array of n elements in non-decreasing order using quick sort
technique.
Algorithm:
Quicksort(A[l..r])
//Sorts a subarray by quicksort
//Input: Subarray of array A[0..n − 1], defined by its left and right indices l and r
//Output: Subarray A[l..r] sorted in nondecreasing order
if l < r
s ←Partition(A[l..r]) //s is a split position
Quicksort(A[l..s − 1])
Quicksort(A[s + 1..r])
HoarePartition(A[l..r])
//Partitions a subarray by Hoare’s algorithm, using the first element as a pivot
//Input: Subarray of array A[0..n − 1], defined by its left and right indices l and r (l<r)
//Output: Partition of A[l..r], with the split position returned as this function’s value
p←A[l]
i ←l;
j ←r + 1
repeat
repeat i ←i + 1 until A[i]≥ p
repeat j ←j − 1 until A[j ]≤ p
swap(A[i], A[j ])
until i ≥ j
swap(A[i], A[j ]) //undo last swap when i ≥ j
swap(A[l], A[j ])
return j
Code:

------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
void getdata(int[], int);
void display(int[], int);
void swap(int[],int,int);
void quicksort(int[],int,int);
int Partition(int [], int , int ) ;
int main()
{
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
printf("Elements before sorting: ");
display(a, n);
int l = 0;
int r = n - 1;
quicksort(a,l,r);
printf("Elements after sorting: ");
display(a, n);
return 0;
}
void getdata(int a[], int n)
{
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
void display(int a[], int n)
{
for (int i = 0; i < n; i++)
{
18 |
printf("%d \t", a[i]);
}
printf("\n");
}
void quicksort(int a[],int l,int r)
{
if(l<r)
{
int s=Partition(a,l,r); //Partition the array into sub-array based on pivot element
quicksort(a,l,s-1); //Sort first sub-array
quicksort(a,s+1,r); //Sort second sub-array
}
}
int Partition(int a[], int l, int r) {
int p, i, j;
p = a[l];
i = l;
j = r + 1;
do {
do {
i++;
} while (a[i] < p);
do {
j--;
} while (a[j] > p);
swap(a, i, j);
} while (i < j);
swap(a,i,j);
swap(a, l, j);
return j;
}
void swap(int a[],int i,int j){
int temp;
temp=a[i];
a[i]=a[j];
a[j]=temp;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
19 |
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
2)Write a C program to sort array of n elements in non-decreasing order using merge sort
technique.
Algorithm:
mergesort(a[0…n-1], low, high)
//Sorts array a[0..n − 1] by recursive mergesort
//Input: An array a[0..n − 1] of orderable elements
//Output: Array a[0..n − 1] sorted in nondecreasing order
mergesort(a[0…n-1], low, high)
if low < high
mid <- (low + high) / 2
mergesort(a, low, mid)
mergesort(a, mid + 1, high)
merge(a, low, mid, high)
Merge(a[0…n-1],low, mid, high)
i ←low
j ←mid+1
k←low
while i <=mid and j <=high do
if a[i]≤ a[j ]
b[k]←a[i++]
else
b[k] ←a[j++]
k←k+1
while i<=mid do
b[k] ←a[i++]
k←k+1
while j<=high do
b[k] ←a[j++]
20 |
k←k+1
//copy array b into array a
for i ← low to high do
a[i]=b[i]
Code:

------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
void getdata(int[], int);
void display(int[], int);
void mergesort(int[], int, int);
void merge(int[], int, int, int);
int main()
{
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
printf("Elements before sorting: ");
display(a, n);
int low = 0;
int high = n - 1;
printf("Low: %d\nHigh: %d\n", low, high);
mergesort(a, low, high);
printf("Elements after sorting: ");
display(a, n);
return 0;
}
void getdata(int a[], int n)
{
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
21 |
void display(int a[], int n)
{
for (int i = 0; i < n; i++)
{
printf("%d \t", a[i]);
}
printf("\n");
}
void mergesort(int a[], int low, int high)
{
int mid;
if (low < high)
{
mid = (low + high) / 2;
mergesort(a, low, mid);
mergesort(a, mid + 1, high);
merge(a, low, mid, high);
}
}
void merge(int a[], int low, int mid, int high)
{
int i = low;
int j = mid + 1;
int k = low;
int b[high + 1];
while (i <= mid && j <= high)
{
if (a[i] <= a[j])
{
b[k] = a[i];
i = i + 1;
}
else
{
b[k] = a[j];
j = j + 1;
}
k = k + 1;
}
while (i <= mid)
{
b[k] = a[i];
i = i + 1;
22 |
k = k + 1;
}
while (j <= high)
{
b[k] = a[j];
j = j + 1;
k = k + 1;
}
for (int i = low; i <= high; i++)
{
a[i] = b[i];
}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
3)Write a C program to traverse all vertices of graph (directed or undirected) using DFS graph
traversal technique.
23 |

------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#define MAX 10
void dfs(int, int[MAX][MAX], int[MAX]);
int main() {
int adj[MAX][MAX], n, source, v[MAX], flag = 1;
printf("Enter the number of vertices: ");
scanf("%d", &n);
printf("Enter the adjacency matrix:\n");
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
scanf("%d", &adj[i][j]);
}
}
printf("Enter source vertex: ");
scanf("%d", &source);
for (int i = 0; i < n; i++) {
v[i] = 0;
}
printf("DFS Traversal:\n");
dfs(source, adj, v);
for (int i = 0; i < n; i++) {
if (v[i] == 0) {
flag = 0;
break;
}
}
if (flag == 1)
printf("Graph connected\n");
else
printf("Graph not connected\n");
return 0;
}
void dfs(int source, int adj[MAX][MAX], int v[MAX]) {
v[source] = 1;
printf("Visited node %d\n", source);
24 |
for (int i = 0; i < MAX; i++) {
if (adj[source][i] == 1 && v[i] == 0) {
dfs(i, adj, v);
}
}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Output:
i)
Enter the number of vertices: 4
Enter the adjacency matrix:
0 1 1 0
1 0 0 1
1 0 0 0
0 1 0 0
Enter source vertex: 0
DFS Traversal:
Visited node 0
Visited node 1
Visited node 3
Visited node 2
Graph connected
ii)
Enter the number of vertices: 4
Enter the adjacency matrix:
0 1 0 0
0 1 0 0
0 0 1 0
1 0 0 0
Enter source vertex: 0
DFS Traversal:
25 |
Visited node 0
Visited node 1
Graph not connected

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
4)Write a C program to traverse all vertices of graph (directed or undirected) using BFS graph
traversal technique.
Code:


#include <stdio.h>
#include <stdlib.h>
#define MAX 10
void bfs(int, int[MAX][MAX], int[MAX]);
int main() {
int adj[MAX][MAX], n, source, v[MAX], flag = 1;
printf("Enter the number of vertices: ");
scanf("%d", &n);
printf("Enter the adjacency matrix:\n");
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
scanf("%d", &adj[i][j]);
}
}
printf("Enter source vertex: ");
26 |
scanf("%d", &source);
for (int i = 0; i < n; i++) {
v[i] = 0;
}
printf("BFS Traversal:\n");
bfs(source, adj, v);
for (int i = 0; i < n; i++) {
if (v[i] == 0) {
flag = 0;
break;
}
}
if (flag == 1)
printf("Graph connected\n");
else
printf("Graph not connected\n");
return 0;
}
void bfs(int source, int adj[MAX][MAX], int v[MAX]) {
int q[MAX], rear = -1, u, front = 0;
v[source] = 1;
printf("Visited node %d\n", source);
q[++rear] = source;
while (front <= rear) {
u = q[front++];
for (int i = 0; i < MAX; i++) {
if (adj[u][i] == 1 && v[i] == 0) {
v[i] = 1;
printf("Visited node %d\n", i);
q[++rear] = i;
}
}
}
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
i)Enter the number of vertices: 4
Enter the adjacency matrix:
0 1 1 0
1 0 0 1
1 0 0 0
0 1 0 0
Enter source vertex: 0
BFS Traversal:
27 |
Visited node 0
Visited node 1
Visited node 2
Visited node 3
Graph connected
ii)
Enter the number of vertices: 4
Enter the adjacency matrix:
0 0 0 0
1 0 0 0
0 0 1 0
0 0 1 0
Enter source vertex: 1
BFS Traversal:
Visited node 1
Visited node 0
Graph not connected

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
5)Write a C program to perform topological sorting on a directed graph.
Algorithm:
TopologicalSort(G(V,E),n)
//Perform topological sort on a directed graph
//Input: Directed Graph G = (V, E)
//Output: Graph G whose vertices are display in topological sorted order
//Initialize an empty queue
for i←0 to n-1
indegree[i]←0
for i←0 to n-1
for j←0 to n-1
if adj[i][j]=1
indegree[j]←indegree[j]+1
for i←0 to n-1

if indegree[i]=0
enqueue(queue,i)
while queue is not empty
v←deque(queue)
append T with v
for j←0 to n-1
if adj[v][i]==1 && visited[j]=0
indegree[j]←indegree[j]-1
if indegree[j]=0
enqueue(queue,j)
visited[j]←1
return T









#include <stdio.h>
#include <stdlib.h>
#define max 10
int adj[max][max], visited[max], T[max], indegree[max];
void topological_sorting(int[][max], int);
int main() {
int i, j, n;
printf("\nEnter number of vertices: \n");
scanf("%d", &n);
printf("\nEnter adjacency matrix for the graph\n");
for (i = 0; i < n; i++) {
printf("\nEnter row %d\n", (i + 1));
for (j = 0; j < n; j++)
scanf("%d", &adj[i][j]);
}
29 |
topological_sorting(adj, n);
printf("\nTopological Order: ");
for (i = 0; i < n; i++)
printf("%d ", T[i]);
printf("\n");
return 0;
}
void topological_sorting(int adj[][max], int n) {
int i, j, q[max], front = 0, rear = -1, v, idx = 0;
// Initialize visited array
for (i = 0; i < n; i++)
visited[i] = 0;
// Calculate indegree
for (i = 0; i < n; i++)
for (j = 0; j < n; j++)
if (adj[i][j] == 1)
indegree[j]++;
// Initialize queue
for (i = 0; i < n; i++)
if (indegree[i] == 0)
q[++rear] = i;
while (front <= rear) {
v = q[front++];
T[idx++] = v;
visited[v] = 1; // Mark vertex as visited
for (j = 0; j < n; j++) {
if (adj[v][j] == 1 && visited[j] == 0) {
indegree[j]--;
if (indegree[j] == 0)
q[++rear] = j;
}
}

}
}


Output:
Enter number of vertices:
5
Enter adjacency matrix for the graph
Enter row 1
0 0 1 0 0
Enter row 2
1 0 1 0 0
Enter row 3
0 0 0 1 1
Enter row 4
0 0 0 0 1
Enter row 5
0 0 0 0 0
Topological Order: 1 0 2 3 4


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
6) Write a C program to search the pattern in the given text using Horspool’s string matching
algorithm.Assume matching done by ignoring case-sensitivity of alphabets.
Algorithm:
HorspoolMatching (P [0..m − 1], T [0..n − 1])
//Implements Horspool’s algorithm for string matching
//Input: Pattern P[0..m − 1] and text T [0..n − 1]
//Output: The index of the left end of the first matching substring or −1 if there are no matches
ShiftTable(P [0..m − 1]) //generate Table of shifts
i ←m – 1 //position of the pattern’s right end
while i ≤ n − 1 do
k←0 //number of matched characters
while k ≤ m − 1 and P[m − 1− k]= T [i − k] do
k←k + 1
31 |
if k = m
return i − m + 1
else
i ←i + Table[T [i]]
return −1
Code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
int table[128];
int m, n;
void ShiftTable(char P[], int m) {
int i, j;
for (i = 0; i < 128; i++)
table[i] = m;
for (j = 0; j <= m - 2; j++)
table[(int)tolower(P[j])] = table[(int)toupper(P[j])] = m - 1 - j;
}
int Horspool(char T[], char P[]) {
int i, k;
ShiftTable(P, m);
i = m - 1;
while (i <= n - 1) {
k = 0;
while (k <= m - 1 && (tolower(P[m - 1 - k]) == tolower(T[i - k])))
k++;
32 |
if (k == m)
return i - m + 1;
else
i += table[(int)T[i]];
}
return -1;
}
int main() {
int pos;
char text[100], pattern[25];
printf("Enter the text:\n");
fgets(text, sizeof(text), stdin);
printf("Enter the pattern:\n");
fgets(pattern, sizeof(pattern), stdin);
n = strlen(text);
m = strlen(pattern) - 1; // Excluding the newline character from fgets
// Convert text and pattern to lowercase for case-insensitive comparison
strlwr(text);
strlwr(pattern);
pos = Horspool(text, pattern);
if (pos == -1)
printf("Pattern not found!!");
else
printf("Pattern %s found at position %d.", pattern, pos + 1);
return 0;
}
Output:
i)
Enter the text:
deepit_nayak
Enter the pattern:
33 |
nayak
Pattern nayak found at position 8.
ii)
Enter the text:
motorola_edge_series
Enter the pattern:
age
Pattern not found!!


------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
7)Write a C program to sort array of n elements in non-decreasing order using heap sort technique.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
void swap(int *a, int *b) {
int tempvar = *a;
*a = *b;
*b = tempvar;
}
void heapify(int arr[], int n, int i) {
int greatest = i;

int leftSide = 2 * i + 1;
int rightSide = 2 * i + 2;
if (leftSide < n && arr[leftSide] > arr[greatest])
greatest = leftSide;
if (rightSide < n && arr[rightSide] > arr[greatest])
greatest = rightSide;
if (greatest != i) {
swap(&arr[i], &arr[greatest]);
heapify(arr, n, greatest);
}
}
void heapSort(int arr[], int n) {
for (int i = n / 2 - 1; i >= 0; i--)
heapify(arr, n, i);
for (int i = n - 1; i >= 0; i--) {
swap(&arr[0], &arr[i]);
heapify(arr, i, 0);
}
}
void printArray(int arr[], int n) {
for (int i = 0; i < n; ++i)
printf("%d ", arr[i]);
printf("\n");
}
void getdata(int a[], int n)
{
for (int i = 0; i < n; i++)
scanf("%d", &a[i]);
}
void display(int a[], int n)
{
for (int i = 0; i < n; i++)
{
printf("%d \t", a[i]);
}
printf("\n");
}
int main() {
int n;
printf("Enter the number of elements: ");
scanf("%d", &n);
int a[n];
getdata(a, n);
35 |
printf("Elements before sorting: ");
display(a, n);
heapSort(a, n);
printf("Elements after sorting: ");
display(a, n);
return 0;
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------
Output:
Enter the number of elements :10
90 -4 41 -14 14 -41 87 98 98 87
Elements before sorting :90 -4 41 -14 14 -41 87 98 98 87
Elements after sorting :-41 -14 -4 14 41 87 87 90 98 98











</pre>
</body>
</html>
